trend[j] = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
bias[j] = 100*(abs(10*slope))/intercept
}
print(j)
}
range(bias,na.rm = T)
median(bias)
hist(bias,breaks=1000,xlim=c(0,25000))
hist(bias,breaks=1000,xlim=c(0,1000))
hist(bias,breaks=10000,xlim=c(0,1000))
median(bias,na.rm = T)
range(trend,na.rm=T)
hist(trend)
hist(bias[trend>0],breaks=10000,xlim=c(0,1000))
hist(bias[trend>0],breaks=10000,xlim=c(0,10000))
hist(bias[trend>0],breaks=10000
)
slope
trend
trend
slope
par(mfrow=c(1,1))
plot(estimated_slopes)
j
j=963
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
plot(estimated_slopes)
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes),'n')
plot(estimated_slopes,type='n')
abline(lm(estimated_slopes~c(1:15)))
plot(estimated_slopes,type='n')
abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
bias[j] = 100*(abs(10*slope))/intercept
}
print(j)
}
hist(bias)
hist(bias,breaks=10000)
hist(bias,breaks=10000,xlim=c(0,max(bias,na.rm=T)))
median(bias)
median(bias,na.rm=T)
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
bias[j] = 100*(abs(10*slope))/intercept
}
print(j)
}
median(bias,na.rm=T)
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
bias[j] = 100*(abs(5*slope))/intercept
}
print(j)
}
median(bias,na.rm=T)
hist(bias,breaks=10000,xlim=c(0,max(bias,na.rm=T)))
mean(bias,na.rm = T)
mode(bias)
head(sort(table(bias)))
tail(sort(table(bias)))
head(bias)
j=1
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
plot(estimated_slopes)
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
100*(abs(5*slope))/intercept
intercept
slope
abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept
(abs(5*slope))
intercept + 5*slope
plot(5,intercept + 5*slope)
points(5,intercept + 5*slope)
estimated_slopes[5]/estimated_slopes[1]
estimated_slopes[5]
estimated_slopes[1]
estimated_slopes[10]
estimated_slopes[10]/estimated_slopes[1]
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
bias[j] = estimated_slopes[10]/(0.001+estimated_slopes[1])
}
print(j)
}
range(bias,na.rm = T)
hist(bias)
hist(bias,breaks=100)
estimated_slopes[10]/(0.001+estimated_slopes[1])
hist(bias,breaks=100,xlim=c(0,100))
median(bias,na.rm=T)
mean(bias,na.rm=T)
estimated_slopes[10]
(0.001+estimated_slopes[1])
j=963
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
estimated_slopes[10]/
estimated_slopes[10]
(0.001+estimated_slopes[1])
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
bias[j] = estimated_slopes[10]/(estimated_slopes[1])
}
print(j)
}
abs(10*slope/intercept)
10*slope+intercept
intercept
0.64 +0.17
(0.64 +0.17)/intercept
10*slope/intercept
estimated_slopes[5]/estimated_slopes[1]
estimated_slopes[5]
estimated_slopes[1]
j=963
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
plot(estimated_slopes)
estimated_slopes[5]
estimated_slopes[1]
estimated_slopes[5]/estimated_slopes[1]
head(trend)
j=1
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
plot(estimated_slopes)
estimated_slopes[10]/estimated_slopes[1]
abs(estimated_slopes[10])/abs(estimated_slopes[1])
abs(estimated_slopes[10])
abs(estimated_slopes[1])
estimated_slopes[1]/estimated_slopes[10]
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[10]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
hist(bias,breaks=50)
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[5]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
hist(bias,breaks=50)
range(bias)
range(bias,na.rm =T)
estimated_slopes[1]/estimated_slopes[5]
estimated_slopes[1]
estimated_slopes[5]
sum(bias<1,na.rm = T)
sum(bias>1,na.rm = T)
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[10]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
hist(bias,breaks=50)
hist(100*bias,breaks=50)
abline(v=100)
abline(v=100,lwd=2,col='red')
(estimated_slopes[1]-estimated_slopes[10])/estimated_slopes[10]
j=1
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
(estimated_slopes[1]-estimated_slopes[10])/estimated_slopes[10]
estimated_slopes[1]
estimated_slopes[10]
estimated_slopes
estimated_slopes=estimated_slopes+1
estimated_slopes
(estimated_slopes[10]-estimated_slopes[1])/estimated_slopes[1]
estimated_slopes[10]
estimated_slopes[1]
estimated_slopes[10]/estimated_slopes[1]
(estimated_slopes[10]-estimated_slopes[1])/estimated_slopes[1]
setwd("~/Desktop/Research/time-series-project_test_branch")
load("data/Keith_et_al_2015_data.Rdata")
dat=dat[,c(1:7,9:14)] #
source('scripts/scripts_to_clean_data/remove_NA_populations.R')
long_time_names=names(table(dat$ID))[as.numeric(table(dat$ID))>34]
long_dat = subset(dat,dat$ID %in% long_time_names)
length(table(long_dat$ID) )
pop_info= long_dat[1,]
for (j in 1:length(table(long_dat$ID))){
index=as.numeric(which(long_dat$ID==long_time_names[j])[1])
pop_info[j,] = long_dat[index,]
}
pop_info$series_length = as.numeric(table(long_dat$ID))
pop_info$variance=NA
pop_info$coefficient_variation=NA
pop_info$overall_trend=NA
pop_info$autocorrelation= NA
pop_info$trend_p_value=NA
pop_info$min_time_for_power=NA
pop_info$percent_change_10years = NA
pop_info$percent_change_IUCNyears = NA
pop_info$popvalue=NA
time_series_data=NULL
source('scripts/calculate_slope.R')
source('scripts/calculate_power_metric.R')
source('scripts/calculate_power_metric.R',chdir = T)
source('scripts/IUCN_analysis.R')
for (j in 1:nrow(pop_info)){
pop= subset(long_dat,long_dat$ID==pop_info$ID[j])
pop = pop[1:35,]
pop$popvalue=as.numeric(pop$popvalue)
pop$popvalue=(pop$popvalue - min(pop$popvalue))/(max(pop$popvalue) - min(pop$popvalue)) #should I standaridize this in a better way
# Option for log of population size
#pop$popvalue = log(pop$popvalue + 0.001)
pop_info$year[j] = pop$year[1]
pop_info$coefficient_variation[j] = sd(pop$popvalue)/mean(pop$popvalue)
pop_info$variance[j] = var(pop$popvalue)
pop_info$overall_trend[j] = calculate_slope(pop$popvalue)
pop_info$autocorrelation[j] = acf(pop$popvalue,plot = FALSE)$acf[2]
pop_info$trend_p_value[j]=calculate_p_value(pop$popvalue)
pop_info$popvalue[j] = pop$popvalue[1] #initial abundance
pop_info$series_length[j] = nrow(pop)
pop_info$IUCN[j] = 3*pop_info$gen_len[j]
if (pop_info$IUCN[j]<10){pop_info$IUCN[j]=10}
pop_info$percent_change_10years[j] = percent_change(pop$popvalue,10)
pop_info$percent_change_IUCNyears[j] = percent_change(pop$popvalue,pop_info$IUCN[j])
pop_info$min_time_for_power[j] = min_time_needed(pop$popvalue,0.05,0.8)
print(paste(j,':',pop_info$min_time_for_power[j],sep=' '))
time_series_data = rbind(time_series_data,pop)
}
setwd("~/Desktop/Research/PortalData/negative_pop_trends_empirical_analyses/data")
save(pop_info,long_dat,long_time_names,file = 'cleaned_timeseries_database.Rdata')
par(mfrow=c(1,3),oma=c(2,2,0.5,0),mar=c(4,4,0,0.5),mgp=c(2.5,0.6,0))
population = subset(long_dat,long_dat$ID==sample_ID_vector[which(trend>0)[1]]) # example time series
example_slopes = calculate_slopes_removing_intial_years(population$popvalue)
plot(population$popvalue[1:30],ylab='population size',xlab='time (years)',las=1,cex.lab=1.4,pch=16)
mtext('(a)',3,line = -2,adj = 0.04,cex = 1.4)
plot(example_slopes,pch=16,ylab='trend estimate',xlab='number of initial years removed',las=1,cex.lab=1.4)
abline(lm(example_slopes~c(1:15)),lwd=2)
text(2,-0.02,labels = paste('slope = ',round(as.numeric(coef(lm(example_slopes~c(1:15)))[2]),5)),pos = 4,cex=1.4)
mtext('(b)',3,line = -2,adj = 0.04,cex = 1.4)
trend_histogram=hist(trend,breaks=50,freq = T,xlim=c(-0.1,0.1),main='',ylim=c(0,50),las=1,cex.lab=1.4,xlab='slope',ylab='frequency',col='black')
box()
setwd("~/Desktop/Research/PortalData/negative_pop_trends_empirical_analyses")
load("data/cleaned_timeseries_database.Rdata")
source('scripts/script_remove_initial_years.R')
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[10]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
trend_histogram=hist(trend,breaks=50,freq = T,xlim=c(-0.1,0.1),main='',ylim=c(0,50),las=1,cex.lab=1.4,xlab='slope',ylab='frequency',col='black')
points(null_data$mids,sum(trend_histogram$counts)*null_data$counts/sum(null_data$counts),col='grey',type='l',lwd=2)
load("data/cleaned_timeseries_database.Rdata")
source('scripts/script_remove_initial_years.R')
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[10]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
mean(bias)
mean(bias,na.rm=T)
mean(bias[trend>0],na.rm=T)
hist(bias[trend>0])
hist(100*bias[trend>0])
hist(bias)
range(bias,na.rm=T)
range(bias[trend>0],na.rm=T)
sum(trend>0)
sum(trend>0,na.rm=T)
sum(is.na(bias))
sum(is.na(bias)==F)
estimated_slopes[10]
estimated_slopes[1]
summary(bis)
summary(bias)
bias
estimated_slopes[10]
estimated_slopes[1]
plot(bias[trend>0])
abline(h=1)
which(bias==max(bias))
which(bias==max(bias,na.rm = T))
bias[762]
j=762
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
plot(population)
plot(population$popvalue)
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
plot(estimated_slopes)
estimated_slopes[10]
estimated_slopes[1]
bias[j]
load("data/cleaned_timeseries_database.Rdata")
source('scripts/script_remove_initial_years.R')
sub_data = pop_info
trend = vector('numeric',nrow(sub_data))
bias = vector('numeric',nrow(sub_data))
sample_ID_vector = as.character(sub_data$ID)
for (j in 1:length(sample_ID_vector)){
population = subset(long_dat,long_dat$ID==sample_ID_vector[j])
estimated_slopes = calculate_slopes_removing_intial_years(population$popvalue)
# remove data if non-stationarity appears to be present
if (any(estimated_slopes>0)){
trend[j]=NA
bias[j]=NA
}else{
# Standardize the values. Should they be standarized? Probably
bias[j]= estimated_slopes[1]/estimated_slopes[10]
estimated_slopes = (estimated_slopes - min(estimated_slopes))/(max(estimated_slopes) - min(estimated_slopes))
#plot(outputs,type='l',col=rgb(0.5,0.5,0.5,0.4))
# a positive value for trend would indicate that slope estimate increases with more time sampled
# abline(lm(estimated_slopes~c(1:15)),col=rgb(0.5,0.5,0.5,0.5))
intercept = as.numeric(coef(lm(estimated_slopes~c(1:15)))[1])
slope = as.numeric(coef(lm(estimated_slopes~c(1:15)))[2])
trend[j] = slope
#bias[j] = 10*slope/intercept
}
print(j)
}
source('scripts/null_dist.R')
save.image(file = 'analysis-outputs/results_for_removing_initial_years_of_time_series.Rdata')
